#!/usr/bin/env ruby

require 'httparty'
require 'nokogiri'
require 'chronic'
require 'csv'

class Match

  attr_accessor :time, :home, :visitor, :location, :league

  def initialize(params={})
    @time = Chronic.parse(params[:time])
    @home = params[:home]
    @visitor = params[:visitor]
    @location = params[:location]
    @league = params[:league]
  end

  def to_s
    formatted_time = time.strftime('%-m/%-e %l:%M%P')
    "#{formatted_time} #{home} vs. #{visitor} at #{location}"
  end

end

module Pva
  class Cli

    class << self

      def run(*args)
        if args.nil? || args.empty?
          self.usage
        else
          self.public_send(args.shift, *args)
        end
      end

      def usage
        puts %{usage: pva command [options]

commands:
teams                   : list all current teams
schedule <team-name>    : show the schedule for the given team
schedules               : show schedules for all of your teams
scores <team-name>      : not yet implemented
standings <team-name>   : not yet implemented
help                    : display this message

Each time you look up a schedule for a team, that team is stored
in your teams cache at ~/.pva. This list is used to determine which
teams you want schedules for when you do `pva schedules`. If you
want to delete a team, simply delete its line from ~/.pva. To add
a team, look up its schedule and it will be added to the list.

}
      end
      alias :help :usage
      alias :h :usage

      def schedule(*args)
        if args.empty?
          puts "Please specify the team name you want a schedule for"
          self.usage
        else
          team_name = args.shift
          teams_provider = TeamsProvider.new
          team = teams_provider.lookup(team_name)
          if team.nil?
            puts "Couldn't find the team you specified. Here is the current list of teams..."
            self.teams
          else
            puts "Schedule for #{team.name}"
            schedule_provider = ScheduleProvider.new
            matches = schedule_provider.get_schedule(team.id)
            matches.each { |m| puts m }
          end
        end
      end

      def schedules
        teams_cache = TeamsCache.new
        teams = teams_cache.all
        if teams.empty?
          puts "No teams were found in your teams cache. Look up a team's schedule to add that team."
        else
          puts "Schedules for Your Teams:\n\n"
          teams.each do |team|
            schedule(team.name)
            puts ""
          end
        end
      end

      def teams(*args)
        teams = TeamsProvider.new.all
        teams.each { |t| puts t }
      end

      def method_missing(method, *args, &blk)
        puts "There is no #{method} command in pva"
        self.usage
      end

    end

  end

  class Team

    attr_reader :id, :name, :league

    def initialize(params={})
      @id = params[:id]
      @name = params[:name]
      @league = params[:league]
    end

    def to_s
      "#{name} (#{league})"
    end

  end

  class TeamsCache

    attr_reader :teams_file

    def initialize(teams_file=nil)
      @teams_file = teams_file || ENV['HOME'] + '/.pva'
    end

    def lookup(team_name)
      return nil unless File.exist?(teams_file)
      CSV.foreach(teams_file) do |row|
        if row[1].casecmp(team_name) == 0
          return Team.new(id: row[0].to_i, name: row[1], league: row[2])
        end
      end
      return nil
    end

    def store(team)
      if lookup(team.name).nil?
        CSV.open(teams_file, 'ab') do |csv|
          csv << [ "#{team.id}", "#{team.name}", "#{team.league}" ]
        end
      end
    end

    def all
      return [] unless File.exist?(teams_file)
      teams = []
      CSV.foreach(teams_file) do |row|
        teams << Team.new(id: row[0].to_i, name: row[1], league: row[2])
      end
      teams
    end

  end

  class TeamsProvider

    attr_reader :cache

    def initialize
      @cache = TeamsCache.new
    end

    def lookup(team_name)
      team = cache.lookup(team_name)
      if team.nil?
        team = all.find { |t| t.name.casecmp(team_name) == 0 }
        cache.store(team) unless team.nil?
      end
      team
    end

    def all
      response = HTTParty.get('http://portlandvolleyball.org/schedules.php')
      doc = Nokogiri::HTML(response)
      teams_select = doc.css('select[name=teams]')
      team_options = teams_select.children
      team_options.map { |option| team_from_option(option) }
        .reject { |t| t == :not_a_team }
    end

    private

    def team_from_option(option)
      id = option['value']
      return :not_a_team if id.nil? || id == ""

      name, league = name_and_league(option.content)
      Team.new(id: id, name: name, league: league)
    end

    def name_and_league(team_string)
      expected_format = /(?<name>.+) \((?<league>.+?)\)/
      if (match_data = expected_format.match(team_string))
        return [match_data[:name], match_data[:league]]
      end
      [team_string, "Unknown"]
    end

  end

  class ScheduleProvider

    SCHEDULES_URL = 'http://portlandvolleyball.org/schedules.php'

    def get_schedule(team_id)
      matches_data(team_id).map { |m| match_from_array(m) }
    end

    private

    def matches_data(team_id)
      response = HTTParty.post(SCHEDULES_URL, body: { teams: team_id })
      doc = Nokogiri::HTML(response)

      doc.css('tr')[1..-1]
        .map { |tr| tr.element_children.map(&:content) }
    end

    def match_from_array(m)
      Match.new({
        time: "#{m[0]} #{m[1]} pm",
        home: m[2],
        visitor: m[3],
        location: m[4],
        league: m[5]
      })
    end

  end

end

Pva::Cli.run(*ARGV)
