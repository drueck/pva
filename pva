#!/usr/bin/env ruby

require 'httparty'
require 'nokogiri'
require 'chronic'
require 'csv'

module Pva
  class Cli

    class << self

      def run(*args)
        if args.nil? || args.empty?
          self.usage
        else
          self.public_send(args.shift, *args)
        end
      end

      def usage
        puts %{usage: pva command [options]

commands:
teams                   : list all current teams
schedules 'team name'   : show the schedule for the given team
schedules               : show schedules for all of your teams
standings 'team name'   : show standings for the given team's division
standings               : show standings for all of your teams' divisions
scores 'team name'      : not yet implemented
help                    : display this message

Each time you look up something for a team that team is stored
in your teams cache at ~/.pva. This list is used to determine which
teams you are interested in if you don't specify one. If you
want to delete a team, simply delete its line from ~/.pva. To add
a team, look up its schedule or standings and it will be added to
the list.

}
      end
      alias :help :usage
      alias :h :usage

      def schedules(*args)
        if args.empty?
          teams_cache = TeamsCache.new
          teams = teams_cache.all
          if teams.empty?
            puts "No teams were found in your teams cache. "\
              "Look up a team's schedule to add that team."
          else
            puts "Schedules for Your Teams:\n\n"
            teams.each do |team|
              schedules(team.name)
              puts ""
            end
          end
        else
          team_name = args.shift
          teams_provider = TeamsProvider.new
          team = teams_provider.lookup(team_name)
          if team.nil?
            puts "Couldn't find the team you specified. Here is the current list of teams..."
            self.teams
          else
            puts "Schedule for #{team.name}"
            schedule_provider = ScheduleProvider.new
            matches = schedule_provider.get_schedule(team.id)
            matches.each { |m| puts m }
          end
        end
      end
      alias :schedule :schedules

      def standings(*args)
        if args.empty?
          teams = TeamsCache.new.all
          if teams.empty?
            puts "No teams were found in your teams cache. "\
              "Look up a team's standings to add that team."
          else
            puts "Standings for Your Teams' Divisions:\n\n"
            teams.map(&:division).uniq.each do |division|
              puts DivisionStandingsProvider.new.get_standings(division)
              puts ""
            end
          end
        else
          team_name = args.shift
          teams_provider = TeamsProvider.new
          team = teams_provider.lookup(team_name)
          if team.nil?
            puts "Couldn't find the team you specified. Here is the current list of teams..."
            self.teams
          else
            puts DivisionStandingsProvider.new.get_standings(team.division)
            puts ""
          end
        end
      end

  # Scores for Court Jesters
  #
  # Date        Time     Opponent          Set 1  Set 2  Set 3  Result  MPs
  # 01/01/2016   8:00pm  Two Dink Minimum  25-22  25-20  15-8   W       4.5
  # 01/01/2016   9:00pm  Two Dink Minimum  25-22  25-20  15-8   W       4.5
  # 01/01/2016  10:00pm  Two Dink Minimum  25-22  25-20  15-8   W       4.5
  #
  # %-10s  %7s  #-{opponent_name_column_width}s  %-5s  %-5s  %-5s  %-6s  %3.1f
  #
  # Record: 1-0, 4.5 Match Points of 4.5 Possible
  #
  # Match Point Calculation
  # .5 for each set won
  # 1 for most total points in the match
  # 2 for winning the match

      # def scores(*args)
      #   if args.empty?
      #     teams = TeamsCache.new.all
      #     if teams.empty?
      #       puts "No teams were found in your teams cache. "\
      #         "Look up a team's scores to add that team."
      #     else
      #       puts "Scores for your teams:\n\n"
      #       teams.each do |team|
      #         scores(team.name)
      #         puts ""
      #       end
      #     end
      #   else
      #     team_name = args.shift
      #     teams_provider = TeamsProvider.new
      #     team = teams_provider.lookup(team_name)
      #     if team.nil?
      #       puts "Couldn't find the team you specified. Here is the current list of teams..."
      #       self.teams
      #     else
      #       puts "Scores for #{team.name}"
      #       scores_provider = ScoresProvider.new
      #       match_scores =
      #       matches = schedule_provider.get_schedule(team.id)
      #       matches.each { |m| puts m }
      #     end
      #   end

      # end

      def teams(*args)
        teams = TeamsProvider.new.all
        teams.each { |t| puts t }
      end

      def method_missing(method, *args, &blk)
        puts "There is no #{method} command in pva"
        self.usage
      end

    end

  end

  class Team

    attr_reader :id, :name, :division

    def initialize(params={})
      @id = params[:id]
      @name = params[:name]
      @division = params[:division]
    end

    def to_s
      "#{name} (#{division})"
    end

  end

  class Match

    attr_accessor :time, :home, :visitor, :location, :division, :set_results

    def initialize(params={})
      @time = Chronic.parse(params[:time])
      @home = params[:home]
      @visitor = params[:visitor]
      @location = params[:location]
      @division = params[:division]
      @set_results = []
    end

    def to_s
      return "#{formatted_date} BYE" if bye?
      "#{formatted_date_and_time} #{home} vs. #{visitor} at #{location}"
    end

    def bye?
      location == "BYE"
    end

    private

    def formatted_date_and_time
      time ? time.strftime('%-m/%e %l:%M%P') : unknown_time
    end

    def formatted_date
      time ? time.strftime('%-m/%e -------') : unknown_time
    end

    def unknown_time
      "??/?? ?:????"
    end

    def add_set_result(set_result)
      set_results << set_result
    end

    def results_for(team)
      return nil unless [home, visitor].include?(team)
      perspective = (team == home ? :home : :visitor)
      MatchResults.new(self, perspective: perspective)
    end

  end

  class SetResult

    def initialize(set:, home:, visitor:)
      @set = set
      @home = home
      @visitor = visitor
    end

    attr_accessor :set, :home, :visitor

    def winner
      return :tie if home == visitor
      home > visitor ? :home : :visitor
    end

    def loser
      return :tie if winner == :tie
      winner == :home ? :visitor : :home
    end

  end

  class MatchResults

    def initialize(match, perspective:)
      @match = match
      @team_side = perspective
      @opponent_side = (perspective == :home ? :visitor : :home)
    end

    def team
      @team ||= match.public_send(team_side)
    end

    def opponent
      @opponent ||= match.public_send(opponent_side)
    end

    def result
      return result_by_point_differential if sets_won == sets_lost
      sets_won > sets_lost ? "W" : "L"
    end

    def sets_won
      @sets_won ||= set_results.map(&:winner).count(team_side)
    end

    def sets_lost
      @sets_lost ||= set_results.map(&:winner).count(opponent_side)
    end

    def point_differential
      @point_differential ||= set_results
        .map { |r| r.public_send(team_side) - r.public_send(opponent_side) }
        .reduce(:+)
    end

    def match_points_earned
      points = sets_won * 0.5
      points += 1 if point_differential > 0
      points += 2 if result == "W"
      points
    end

    def to_s(opponent_name_column_width: self.opponent.length)
      format = "%-10s  %7s  %-#{opponent_name_column_width}s  " +
               "%-5s  %-5s  %-5s  %-6s  %3.1f"
      data = [match_date_string, match_time_string, opponent,
              set_scores_string(1),
              set_scores_string(2),
              set_scores_string(3),
              result, match_points_earned]
      format % data
    end

    private

    attr_reader :match, :team_side, :opponent_side

    def match_date_string
      match.time.strftime('%m/%d/%Y')
    end

    def match_time_string
      match.time.strftime('%l:%M%P')
    end

    def set_scores_string(set_number)
      set_result = set_results.find { |sr| sr.set == set_number }
      return "" if set_result.nil?

      team_score = set_result.public_send(team_side)
      opponent_score = set_result.public_send(opponent_side)
      "#{team_score}-#{opponent_score}"
    end

    def set_results
      match.set_results
    end

    def result_by_point_differential
      return "T" if point_differential == 0
      point_differential > 0 ? "W" : "L"
    end

  end

  class Standing

    attr_reader :team_name, :wins, :losses, :winning_percentage,
      :match_points, :match_points_possible, :match_point_percentage

    def initialize(params={})
      @team_name = params[:team_name]
      @wins = Integer(params[:wins])
      @losses = Integer(params[:losses])
      @winning_percentage = Float(params[:winning_percentage])
      @match_points = Float(params[:match_points])
      @match_points_possible = Float(params[:match_points_possible])
      @match_point_percentage = Float(params[:match_point_percentage])
    end

  end

  class DivisionStandings

    attr_reader :division_name, :standings

    def initialize(params={})
      @division_name = params[:division_name]
      @standings = params[:standings]
    end

    def to_s
      division_name + "\n\n" +
        formatted_headings + "\n" +
        formatted_standings
    end

    private

    def formatted_headings
      sprintf(format, *headings)
    end

    def formatted_standings
      standings.map { |s| sprintf(format, *column_values(s)) }.join("\n")
    end

    def format
      @format ||= "%-#{name_column_width}s" +
        numeric_column_widths.map { |w| "%#{w}s" }.join
    end

    def column_values(stats)
      [stats.team_name,
       stats.wins,
       stats.losses,
       sprintf("%.02f", stats.winning_percentage),
       sprintf("%4.1f / %4.1f", stats.match_points, stats.match_points_possible),
       sprintf("%.2f", stats.match_point_percentage)]
    end

    def headings
      ["Team", "Wins", "Losses", "Winning %", "Match Points", "Match Point %"]
    end

    def name_column_width
      ["Team".length, max_team_name_length].max + gutter_width
    end

    def max_team_name_length
      return 0 if standings.empty?
      standings.map(&:team_name).map(&:length).max
    end

    def numeric_column_widths
      headings[1..-1].map { |heading| heading.length + gutter_width }
    end

    def gutter_width
      2
    end

  end

  class TeamsCache

    attr_reader :teams_file

    def initialize(teams_file=nil)
      @teams_file = teams_file || ENV['HOME'] + '/.pva'
    end

    def lookup(team_name)
      return nil unless File.exist?(teams_file)
      CSV.foreach(teams_file) do |row|
        if row[1].casecmp(team_name) == 0
          return Team.new(id: row[0].to_i, name: row[1], division: row[2])
        end
      end
      return nil
    end

    def store(team)
      if lookup(team.name).nil?
        CSV.open(teams_file, 'ab') do |csv|
          csv << [ "#{team.id}", "#{team.name}", "#{team.division}" ]
        end
      end
    end

    def all
      return [] unless File.exist?(teams_file)
      teams = []
      CSV.foreach(teams_file) do |row|
        teams << Team.new(id: row[0].to_i, name: row[1], division: row[2])
      end
      teams
    end

  end

  class TeamsProvider

    attr_reader :cache

    def initialize
      @cache = TeamsCache.new
    end

    def lookup(team_name)
      team = cache.lookup(team_name)
      if team.nil?
        team = all.find { |t| t.name.casecmp(team_name) == 0 }
        cache.store(team) unless team.nil?
      end
      team
    end

    def all
      response = HTTParty.get('http://portlandvolleyball.org/schedules.php')
      doc = Nokogiri::HTML(response)
      teams_select = doc.css('select[name=teams]')
      team_options = teams_select.children
      team_options.map { |option| team_from_option(option) }
        .reject { |t| t == :not_a_team }
    end

    private

    def team_from_option(option)
      id = option['value']
      return :not_a_team if id.nil? || id == ""

      name, division = name_and_division(option.content)
      Team.new(id: id, name: name, division: division)
    end

    def name_and_division(team_string)
      expected_format = /(?<name>.+) \((?<division>.+?)\)/
      if (match_data = expected_format.match(team_string))
        return [match_data[:name], match_data[:division]]
      end
      [team_string, "Unknown"]
    end

  end

  class ScheduleProvider

    SCHEDULES_URL = 'http://portlandvolleyball.org/schedules.php'

    def get_schedule(team_id)
      matches_data(team_id).map { |m| match_from_array(m) }
    end

    private

    def matches_data(team_id)
      response = HTTParty.post(SCHEDULES_URL, body: { teams: team_id })
      doc = Nokogiri::HTML(response)

      doc.css('tr')[1..-1]
        .map { |tr| tr.element_children.map(&:content).map(&:strip) }
    end

    def match_from_array(m)
      Match.new({
        time: "#{m[0]} #{m[1]} pm",
        home: m[2],
        visitor: m[3],
        location: m[4],
        division: m[5]
      })
    end

  end

  class DivisionStandingsProvider

    STANDINGS_URL = 'http://portlandvolleyball.org/standings.php'

    def get_standings(division_name)
      DivisionStandings.new(division_name: division_name,
                          standings: standings(division_name))
    end

    private

    def standings(division_name)
      standings_data(division_name).map { |s| standing_from_array(s) }
    end

    def standings_data(division_name)
      response = HTTParty.get(STANDINGS_URL)
      doc = Nokogiri::HTML(response)

      doc.xpath("//a[@name='#{division_name}']/following::table[1]/tr")[1..-1]
        .map { |tr| tr.element_children.map(&:content) }
    end

    def standing_from_array(s)
      Standing.new(
        team_name: s[0],
        wins: s[1],
        losses: s[2],
        winning_percentage: s[3],
        match_points: s[4],
        match_points_possible: s[5],
        match_point_percentage: s[6]
      )
    end

  end

end

Pva::Cli.run(*ARGV)
