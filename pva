#!/usr/bin/env ruby

require 'httparty'
require 'nokogiri'
require 'chronic'
require 'csv'

module Pva
  class Cli

    class << self

      def run(*args)
        if args.nil? || args.empty?
          self.usage
        else
          self.public_send(args.shift, *args)
        end
      end

      def usage
        puts %{usage: pva command [options]

commands:
teams                   : list all current teams
schedules 'team name'   : show the schedule for the given team
schedules               : show schedules for all of your teams
standings 'team name'   : show standings for the given team's division
standings               : show standings for all of your teams' divisions
scores 'team name'      : not yet implemented
help                    : display this message

Each time you look up something for a team that team is stored
in your teams cache at ~/.pva. This list is used to determine which
teams you are interested in if you don't specify one. If you
want to delete a team, simply delete its line from ~/.pva. To add
a team, look up its schedule or standings and it will be added to
the list.

}
      end
      alias :help :usage
      alias :h :usage

      def schedules(*args)
        if args.empty?
          teams_cache = TeamsCache.new
          teams = teams_cache.all
          if teams.empty?
            puts "No teams were found in your teams cache. "\
              "Look up a team's schedule to add that team."
          else
            puts "Schedules for Your Teams:\n\n"
            teams.each do |team|
              schedules(team.name)
              puts ""
            end
          end
        else
          team_name = args.shift
          teams_provider = TeamsProvider.new
          team = teams_provider.lookup(team_name)
          if team.nil?
            puts "Couldn't find the team you specified. Here is the current list of teams..."
            self.teams
          else
            puts "Schedule for #{team.name}"
            schedule_provider = ScheduleProvider.new
            matches = schedule_provider.get_schedule(team.id)
            matches.each { |m| puts m }
          end
        end
      end
      alias :schedule :schedules

      def standings(*args)
        if args.empty?
          teams = TeamsCache.new.all
          if teams.empty?
            puts "No teams were found in your teams cache. "\
              "Look up a team's standings to add that team."
          else
            puts "Standings for Your Teams' Divisions:\n\n"
            teams.map(&:division).uniq.each do |division|
              puts DivisionStandingsProvider.new.get_standings(division)
              puts ""
            end
          end
        else
          team_name = args.shift
          teams_provider = TeamsProvider.new
          team = teams_provider.lookup(team_name)
          if team.nil?
            puts "Couldn't find the team you specified. Here is the current list of teams..."
            self.teams
          else
            puts DivisionStandingsProvider.new.get_standings(team.division)
            puts ""
          end
        end
      end

      def teams(*args)
        teams = TeamsProvider.new.all
        teams.each { |t| puts t }
      end

      def method_missing(method, *args, &blk)
        puts "There is no #{method} command in pva"
        self.usage
      end

    end

  end

  class Team

    attr_reader :id, :name, :division

    def initialize(params={})
      @id = params[:id]
      @name = params[:name]
      @division = params[:division]
    end

    def to_s
      "#{name} (#{division})"
    end

  end

  class Match

    attr_accessor :time, :home, :visitor, :location, :division

    def initialize(params={})
      @time = Chronic.parse(params[:time])
      @home = params[:home]
      @visitor = params[:visitor]
      @location = params[:location]
      @division = params[:division]
    end

    def to_s
      return "#{formatted_date} BYE" if bye?
      "#{formatted_date_and_time} #{home} vs. #{visitor} at #{location}"
    end

    def bye?
      location == "BYE"
    end

    private

    def formatted_date_and_time
      time ? time.strftime('%-m/%e %l:%M%P') : unknown_time
    end

    def formatted_date
      time ? time.strftime('%-m/%e -------') : unknown_time
    end

    def unknown_time
      "??/?? ?:????"
    end
  end

  class Standing

    attr_reader :team_name, :wins, :losses, :winning_percentage,
      :match_points, :match_points_possible, :match_point_percentage

    def initialize(params={})
      @team_name = params[:team_name]
      @wins = Integer(params[:wins])
      @losses = Integer(params[:losses])
      @winning_percentage = Float(params[:winning_percentage])
      @match_points = Float(params[:match_points])
      @match_points_possible = Float(params[:match_points_possible])
      @match_point_percentage = Float(params[:match_point_percentage])
    end

  end

  class DivisionStandings

    attr_reader :division_name, :standings

    def initialize(params={})
      @division_name = params[:division_name]
      @standings = params[:standings]
    end

    def to_s
      division_name + "\n\n" +
        formatted_headings + "\n" +
        formatted_standings
    end

    private

    def formatted_headings
      sprintf(format, *headings)
    end

    def formatted_standings
      standings.map { |s| sprintf(format, *column_values(s)) }.join("\n")
    end

    def format
      @format ||= "%-#{name_column_width}s" +
        numeric_column_widths.map { |w| "%#{w}s" }.join
    end

    def column_values(stats)
      [stats.team_name,
       stats.wins,
       stats.losses,
       sprintf("%.02f", stats.winning_percentage),
       sprintf("%4.1f / %4.1f", stats.match_points, stats.match_points_possible),
       sprintf("%.2f", stats.match_point_percentage)]
    end

    def headings
      ["Team", "Wins", "Losses", "Winning %", "Match Points", "Match Point %"]
    end

    def name_column_width
      ["Team".length, max_team_name_length].max + gutter_width
    end

    def max_team_name_length
      return 0 if standings.empty?
      standings.map(&:team_name).map(&:length).max
    end

    def numeric_column_widths
      headings[1..-1].map { |heading| heading.length + gutter_width }
    end

    def gutter_width
      2
    end

  end

  class TeamsCache

    attr_reader :teams_file

    def initialize(teams_file=nil)
      @teams_file = teams_file || ENV['HOME'] + '/.pva'
    end

    def lookup(team_name)
      return nil unless File.exist?(teams_file)
      CSV.foreach(teams_file) do |row|
        if row[1].casecmp(team_name) == 0
          return Team.new(id: row[0].to_i, name: row[1], division: row[2])
        end
      end
      return nil
    end

    def store(team)
      if lookup(team.name).nil?
        CSV.open(teams_file, 'ab') do |csv|
          csv << [ "#{team.id}", "#{team.name}", "#{team.division}" ]
        end
      end
    end

    def all
      return [] unless File.exist?(teams_file)
      teams = []
      CSV.foreach(teams_file) do |row|
        teams << Team.new(id: row[0].to_i, name: row[1], division: row[2])
      end
      teams
    end

  end

  class TeamsProvider

    attr_reader :cache

    def initialize
      @cache = TeamsCache.new
    end

    def lookup(team_name)
      team = cache.lookup(team_name)
      if team.nil?
        team = all.find { |t| t.name.casecmp(team_name) == 0 }
        cache.store(team) unless team.nil?
      end
      team
    end

    def all
      response = HTTParty.get('http://portlandvolleyball.org/schedules.php')
      doc = Nokogiri::HTML(response)
      teams_select = doc.css('select[name=teams]')
      team_options = teams_select.children
      team_options.map { |option| team_from_option(option) }
        .reject { |t| t == :not_a_team }
    end

    private

    def team_from_option(option)
      id = option['value']
      return :not_a_team if id.nil? || id == ""

      name, division = name_and_division(option.content)
      Team.new(id: id, name: name, division: division)
    end

    def name_and_division(team_string)
      expected_format = /(?<name>.+) \((?<division>.+?)\)/
      if (match_data = expected_format.match(team_string))
        return [match_data[:name], match_data[:division]]
      end
      [team_string, "Unknown"]
    end

  end

  class ScheduleProvider

    SCHEDULES_URL = 'http://portlandvolleyball.org/schedules.php'

    def get_schedule(team_id)
      matches_data(team_id).map { |m| match_from_array(m) }
    end

    private

    def matches_data(team_id)
      response = HTTParty.post(SCHEDULES_URL, body: { teams: team_id })
      doc = Nokogiri::HTML(response)

      doc.css('tr')[1..-1]
        .map { |tr| tr.element_children.map(&:content).map(&:strip) }
    end

    def match_from_array(m)
      Match.new({
        time: "#{m[0]} #{m[1]} pm",
        home: m[2],
        visitor: m[3],
        location: m[4],
        division: m[5]
      })
    end

  end

  class DivisionStandingsProvider

    STANDINGS_URL = 'http://portlandvolleyball.org/standings.php'

    def get_standings(division_name)
      DivisionStandings.new(division_name: division_name,
                          standings: standings(division_name))
    end

    private

    def standings(division_name)
      standings_data(division_name).map { |s| standing_from_array(s) }
    end

    def standings_data(division_name)
      response = HTTParty.get(STANDINGS_URL)
      doc = Nokogiri::HTML(response)

      doc.xpath("//a[@name='#{division_name}']/following::table[1]/tr")[1..-1]
        .map { |tr| tr.element_children.map(&:content) }
    end

    def standing_from_array(s)
      Standing.new(
        team_name: s[0],
        wins: s[1],
        losses: s[2],
        winning_percentage: s[3],
        match_points: s[4],
        match_points_possible: s[5],
        match_point_percentage: s[6]
      )
    end

  end

end

Pva::Cli.run(*ARGV)
